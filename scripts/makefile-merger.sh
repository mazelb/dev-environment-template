#!/bin/bash

###############################################################################
# Makefile Merger
# Intelligently merges multiple Makefiles with namespace support
###############################################################################

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Define print functions if not already available
if ! command -v print_error &> /dev/null; then
    print_error() { echo -e "${RED}✗${NC} $1" >&2; }
    print_warning() { echo -e "${YELLOW}⚠${NC} $1" >&2; }
    print_info() { echo -e "${CYAN}ℹ${NC} $1"; }
    print_success() { echo -e "${GREEN}✓${NC} $1"; }
fi

###############################################################################
# Makefile Merger with Namespacing
###############################################################################

# Merge multiple Makefiles with namespaced targets
# Usage: merge_makefiles output_file input1:namespace1 input2:namespace2 [...]
merge_makefiles() {
    local output_file=$1
    shift
    local input_specs=("$@")

    if [ ${#input_specs[@]} -eq 0 ]; then
        print_error "No input files specified"
        return 1
    fi

    print_info "Merging ${#input_specs[@]} Makefiles into $output_file"

    local temp_file="${output_file}.tmp.$$"

    # Header
    cat > "$temp_file" << 'EOF'
# ===================================================================
# MERGED MAKEFILE
# ===================================================================
# This file was automatically generated by merging multiple Makefiles
# Targets are namespaced to avoid conflicts
# ===================================================================

.DEFAULT_GOAL := help

EOF

    # Track all targets and phony declarations
    declare -a all_phony_targets
    declare -a all_composite_targets

    # Process each Makefile
    for spec in "${input_specs[@]}"; do
        local input_file=$(echo "$spec" | cut -d':' -f1)
        local namespace=$(echo "$spec" | cut -d':' -f2-)

        # Default namespace to filename if not provided
        if [ "$namespace" = "$input_file" ] || [ -z "$namespace" ]; then
            namespace=$(basename "$(dirname "$input_file")")
        fi

        if [ ! -f "$input_file" ]; then
            print_warning "File not found, skipping: $input_file"
            continue
        fi

        print_info "Processing: $input_file (namespace: $namespace)"

        # Add section header
        cat >> "$temp_file" << EOF

# ===================================================================
# ${namespace^^} TARGETS
# ===================================================================

EOF

        # Extract PHONY targets
        local phony_targets=$(grep "^\.PHONY:" "$input_file" | sed 's/^\.PHONY:[[:space:]]*//' || true)

        # Process file line by line
        local in_target=false
        local current_target=""

        while IFS= read -r line || [ -n "$line" ]; do
            # Skip .PHONY and .DEFAULT_GOAL declarations (we'll handle them)
            if [[ "$line" =~ ^\.PHONY: ]] || [[ "$line" =~ ^\.DEFAULT_GOAL ]]; then
                continue
            fi

            # Detect target definition
            if [[ "$line" =~ ^([a-zA-Z0-9_-]+):(.*)$ ]] && [[ ! "$line" =~ ^[[:space:]] ]]; then
                local target_name="${BASH_REMATCH[1]}"
                local target_deps="${BASH_REMATCH[2]}"

                # Namespace the target
                local namespaced_target="${namespace}-${target_name}"
                current_target="$namespaced_target"

                # Namespace dependencies
                local namespaced_deps=""
                for dep in $target_deps; do
                    # Only namespace if it's a known phony target
                    if echo "$phony_targets" | grep -q "\b$dep\b"; then
                        namespaced_deps="$namespaced_deps ${namespace}-${dep}"
                    else
                        namespaced_deps="$namespaced_deps $dep"
                    fi
                done

                echo "${namespaced_target}:${namespaced_deps}" >> "$temp_file"

                # Track phony targets
                if echo "$phony_targets" | grep -q "\b$target_name\b"; then
                    all_phony_targets+=("$namespaced_target")
                fi

                # Track composite targets
                all_composite_targets+=("$namespaced_target")

                in_target=true
            elif [ "$in_target" = true ]; then
                # Inside a target, output recipe lines as-is
                echo "$line" >> "$temp_file"

                # End of target (empty line or new target)
                if [ -z "$line" ]; then
                    in_target=false
                fi
            elif [[ "$line" =~ ^[[:space:]]*# ]] || [ -z "$line" ]; then
                # Preserve comments and empty lines outside targets
                echo "$line" >> "$temp_file"
            fi
        done < "$input_file"
    done

    # Add composite targets
    cat >> "$temp_file" << EOF

# ===================================================================
# COMPOSITE TARGETS (run all namespaced targets)
# ===================================================================

EOF

    # Create "all" targets per namespace
    for spec in "${input_specs[@]}"; do
        local input_file=$(echo "$spec" | cut -d':' -f1)
        local namespace=$(echo "$spec" | cut -d':' -f2-)

        if [ "$namespace" = "$input_file" ] || [ -z "$namespace" ]; then
            namespace=$(basename "$(dirname "$input_file")")
        fi

        # Find targets for this namespace
        local namespace_targets=()
        for target in "${all_composite_targets[@]}"; do
            if [[ "$target" =~ ^${namespace}- ]]; then
                namespace_targets+=("$target")
            fi
        done

        if [ ${#namespace_targets[@]} -gt 0 ]; then
            echo "${namespace}-all: ${namespace_targets[*]}" >> "$temp_file"
            all_phony_targets+=("${namespace}-all")
        fi
    done

    # Add "all" target that runs everything
    echo "" >> "$temp_file"
    echo "all: ${all_composite_targets[*]}" >> "$temp_file"
    all_phony_targets+=("all")

    # Add help target
    cat >> "$temp_file" << 'EOF'

# ===================================================================
# HELP TARGET
# ===================================================================

help:  ## Show this help message
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-30s %s\n", $$1, $$2}'

EOF

    all_phony_targets+=("help")

    # Add .PHONY declarations
    echo "" >> "$temp_file"
    echo ".PHONY: ${all_phony_targets[*]}" >> "$temp_file"

    mv "$temp_file" "$output_file"
    print_success "Makefile merge complete: $output_file"
    return 0
}

###############################################################################
# Extract targets from Makefile
###############################################################################

# List all targets in a Makefile
list_makefile_targets() {
    local input_file=$1

    if [ ! -f "$input_file" ]; then
        print_error "File not found: $input_file"
        return 1
    fi

    print_info "Targets in $input_file:"

    grep -E '^[a-zA-Z0-9_-]+:' "$input_file" | sed 's/:.*//' | while read target; do
        echo "  - $target"
    done

    return 0
}

###############################################################################
# Main Execution
###############################################################################

# Main execution - only run if script is executed directly (not sourced)
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    if [ $# -eq 0 ]; then
        echo "Makefile Merger"
        echo ""
        echo "Usage:"
        echo "  $0 merge <output_file> <input1:namespace1> <input2:namespace2> [...]"
        echo "  $0 list-targets <makefile>"
        echo ""
        echo "Examples:"
        echo "  # Merge with namespacing"
        echo "  $0 merge Makefile base/Makefile:base rag/Makefile:rag"
        echo ""
        echo "  # List targets"
        echo "  $0 list-targets Makefile"
        echo ""
        exit 0
    fi

    command=$1
    shift

    case "$command" in
        merge)
            if [ $# -lt 2 ]; then
                print_error "Usage: $0 merge <output_file> <input1:namespace1> <input2:namespace2> [...]"
                exit 1
            fi
            merge_makefiles "$@"
            ;;
        list-targets)
            if [ $# -ne 1 ]; then
                print_error "Usage: $0 list-targets <makefile>"
                exit 1
            fi
            list_makefile_targets "$@"
            ;;
        *)
            print_error "Unknown command: $command"
            exit 1
            ;;
    esac
fi

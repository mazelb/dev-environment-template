#!/bin/bash

###############################################################################
# Environment File (.env) Merger
# Intelligently merges multiple .env files with section headers
###############################################################################

set -e

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Define print functions if not already available
if ! command -v print_error &> /dev/null; then
    print_error() { echo -e "${RED}✗${NC} $1" >&2; }
    print_warning() { echo -e "${YELLOW}⚠${NC} $1" >&2; }
    print_info() { echo -e "${CYAN}ℹ${NC} $1"; }
    print_success() { echo -e "${GREEN}✓${NC} $1"; }
fi

###############################################################################
# .env File Merger
###############################################################################

# Merge multiple .env files with section headers
# Usage: merge_env_files output_file input_file1:label1 input_file2:label2 [...]
merge_env_files() {
    local output_file=$1
    shift
    local input_specs=("$@")

    if [ ${#input_specs[@]} -eq 0 ]; then
        print_error "No input files specified"
        return 1
    fi

    print_info "Merging ${#input_specs[@]} .env files into $output_file"

    # Track all variables to detect conflicts
    declare -A all_vars
    declare -A var_sources
    local temp_file="${output_file}.tmp.$$"

    # Header
    cat > "$temp_file" << 'EOF'
# ===================================================================
# MERGED ENVIRONMENT CONFIGURATION
# ===================================================================
# This file was automatically generated by merging multiple .env files
# Check for conflicts marked with [CONFLICT] below
#
# Generated: $(date)
# ===================================================================

EOF

    # Process each input file
    for spec in "${input_specs[@]}"; do
        # Parse file:label format
        local input_file=$(echo "$spec" | cut -d':' -f1)
        local label=$(echo "$spec" | cut -d':' -f2-)

        # Default label to filename if not provided
        if [ "$label" = "$input_file" ] || [ -z "$label" ]; then
            label=$(basename "$(dirname "$input_file")")
        fi

        if [ ! -f "$input_file" ]; then
            print_warning "File not found, skipping: $input_file"
            continue
        fi

        print_info "Processing: $input_file ($label)"

        # Add section header
        cat >> "$temp_file" << EOF

# ===================================================================
# ${label^^} CONFIGURATION
# ===================================================================
EOF

        # Process file line by line
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip empty lines at the start of section
            [ -z "$line" ] && continue

            # Preserve comments
            if [[ "$line" =~ ^[[:space:]]*# ]]; then
                echo "$line" >> "$temp_file"
                continue
            fi

            # Extract variable name
            if [[ "$line" =~ ^[[:space:]]*([A-Z_][A-Z0-9_]*)= ]]; then
                local var_name="${BASH_REMATCH[1]}"

                # Check for conflicts
                if [ -n "${all_vars[$var_name]}" ]; then
                    print_warning "  Conflict: $var_name (already defined in ${var_sources[$var_name]})"
                    echo "# [CONFLICT] $var_name already defined in ${var_sources[$var_name]}" >> "$temp_file"
                    echo "# Original: ${all_vars[$var_name]}" >> "$temp_file"
                    echo "# $label: $line" >> "$temp_file"
                else
                    all_vars[$var_name]="$line"
                    var_sources[$var_name]="$label"
                    echo "$line" >> "$temp_file"
                fi
            else
                # Non-variable line (might be continuation or malformed)
                echo "$line" >> "$temp_file"
            fi
        done < "$input_file"
    done

    # Add footer
    cat >> "$temp_file" << 'EOF'

# ===================================================================
# END OF MERGED CONFIGURATION
# ===================================================================
# Review any [CONFLICT] markers above and resolve manually
# ===================================================================
EOF

    mv "$temp_file" "$output_file"

    # Report conflicts
    local conflict_count=$(grep -c "\[CONFLICT\]" "$output_file" || true)
    if [ "$conflict_count" -gt 0 ]; then
        print_warning "Merge complete with $conflict_count conflict(s) - review $output_file"
    else
        print_success ".env merge complete: $output_file"
    fi

    return 0
}

###############################################################################
# Merge with Deduplication
###############################################################################

# Merge .env files with automatic deduplication (last value wins)
merge_env_files_deduplicated() {
    local output_file=$1
    shift
    local input_files=("$@")

    if [ ${#input_files[@]} -eq 0 ]; then
        print_error "No input files specified"
        return 1
    fi

    print_info "Merging ${#input_files[@]} .env files with deduplication"

    declare -A final_vars
    declare -A var_comments

    # Process all files (later files override earlier ones)
    for input_file in "${input_files[@]}"; do
        if [ ! -f "$input_file" ]; then
            print_warning "File not found, skipping: $input_file"
            continue
        fi

        print_info "Processing: $input_file"

        local current_comment=""
        while IFS= read -r line || [ -n "$line" ]; do
            # Accumulate comments
            if [[ "$line" =~ ^[[:space:]]*# ]]; then
                if [ -n "$current_comment" ]; then
                    current_comment="$current_comment"$'\n'"$line"
                else
                    current_comment="$line"
                fi
                continue
            fi

            # Empty line resets comment accumulation
            if [ -z "$line" ]; then
                current_comment=""
                continue
            fi

            # Extract variable
            if [[ "$line" =~ ^[[:space:]]*([A-Z_][A-Z0-9_]*)=(.*)$ ]]; then
                local var_name="${BASH_REMATCH[1]}"
                local var_value="${BASH_REMATCH[2]}"

                final_vars[$var_name]="$var_name=$var_value"

                # Store comment if available
                if [ -n "$current_comment" ]; then
                    var_comments[$var_name]="$current_comment"
                fi

                current_comment=""
            fi
        done < "$input_file"
    done

    # Write output
    cat > "$output_file" << 'EOF'
# ===================================================================
# MERGED ENVIRONMENT CONFIGURATION (Deduplicated)
# ===================================================================
# Variables with conflicts have been resolved (last value wins)
# ===================================================================

EOF

    # Write all variables
    for var_name in "${!final_vars[@]}"; do
        # Write comment if available
        if [ -n "${var_comments[$var_name]}" ]; then
            echo "${var_comments[$var_name]}" >> "$output_file"
        fi
        echo "${final_vars[$var_name]}" >> "$output_file"
        echo "" >> "$output_file"
    done

    print_success ".env merge complete (deduplicated): $output_file"
    return 0
}

###############################################################################
# Extract variables by prefix
###############################################################################

# Extract variables with a specific prefix from .env file
extract_env_vars_by_prefix() {
    local input_file=$1
    local prefix=$2
    local output_file=$3

    if [ ! -f "$input_file" ]; then
        print_error "Input file not found: $input_file"
        return 1
    fi

    if [ -z "$prefix" ]; then
        print_error "Prefix is required"
        return 1
    fi

    print_info "Extracting variables with prefix '$prefix' from $input_file"

    grep "^${prefix}" "$input_file" > "$output_file" 2>/dev/null || echo -n "" > "$output_file"

    local count=$(wc -l < "$output_file" || echo 0)
    print_success "Extracted $count variables to $output_file"
    return 0
}

###############################################################################
# Validate .env file
###############################################################################

# Validate .env file syntax
validate_env_file() {
    local input_file=$1

    if [ ! -f "$input_file" ]; then
        print_error "File not found: $input_file"
        return 1
    fi

    print_info "Validating $input_file"

    local line_num=0
    local errors=0

    while IFS= read -r line || [ -n "$line" ]; do
        ((line_num++))

        # Skip empty lines and comments
        [ -z "$line" ] && continue
        [[ "$line" =~ ^[[:space:]]*# ]] && continue

        # Check for valid variable format
        if ! [[ "$line" =~ ^[[:space:]]*[A-Z_][A-Z0-9_]*=.*$ ]]; then
            print_error "Line $line_num: Invalid format: $line"
            ((errors++))
        fi
    done < "$input_file"

    if [ $errors -eq 0 ]; then
        print_success "Validation passed: $input_file"
        return 0
    else
        print_error "Validation failed with $errors error(s)"
        return 1
    fi
}

###############################################################################
# Main Execution
###############################################################################

# Main execution - only run if script is executed directly (not sourced)
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    if [ $# -eq 0 ]; then
        echo "Environment File (.env) Merger"
        echo ""
        echo "Usage:"
        echo "  $0 merge <output_file> <input1:label1> <input2:label2> [...]"
        echo "  $0 merge-dedup <output_file> <input1> <input2> [...]"
        echo "  $0 extract <input_file> <prefix> <output_file>"
        echo "  $0 validate <input_file>"
        echo ""
        echo "Examples:"
        echo "  # Merge with section headers and conflict detection"
        echo "  $0 merge .env base/.env:BASE rag/.env:RAG"
        echo ""
        echo "  # Merge with deduplication (last wins)"
        echo "  $0 merge-dedup .env base/.env rag/.env"
        echo ""
        echo "  # Extract variables by prefix"
        echo "  $0 extract .env DATABASE_ db-vars.env"
        echo ""
        echo "  # Validate .env syntax"
        echo "  $0 validate .env"
        echo ""
        exit 0
    fi

    command=$1
    shift

    case "$command" in
        merge)
            if [ $# -lt 2 ]; then
                print_error "Usage: $0 merge <output_file> <input1:label1> <input2:label2> [...]"
                exit 1
            fi
            merge_env_files "$@"
            ;;
        merge-dedup)
            if [ $# -lt 2 ]; then
                print_error "Usage: $0 merge-dedup <output_file> <input1> <input2> [...]"
                exit 1
            fi
            merge_env_files_deduplicated "$@"
            ;;
        extract)
            if [ $# -ne 3 ]; then
                print_error "Usage: $0 extract <input_file> <prefix> <output_file>"
                exit 1
            fi
            extract_env_vars_by_prefix "$@"
            ;;
        validate)
            if [ $# -ne 1 ]; then
                print_error "Usage: $0 validate <input_file>"
                exit 1
            fi
            validate_env_file "$@"
            ;;
        *)
            print_error "Unknown command: $command"
            exit 1
            ;;
    esac
fi
